

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>


#define RAND_DIVISOR 100000000
#define TRUE 1
typedef int Material;
#define BUFFER_SIZE 3
#define MATERIAL_1 1
#define MATERIAL_2 2
#define MATERIAL_3 3



class InputBuffer  //a stack buffer to store the Material
{
private:
	int size;
	int current;
	Material * ary;
	int m1_counter;
	int m2_counter;
	int m3_counter;
public:
	InputBuffer(int s):size(s),current(0),m1_counter(0),m2_counter(0),m3_counter(0){ary = new int[size];}
	~InputBuffer(){delete ary;}
	int push(Material item)
	{
		
			if(current < size)
			{
				if(item == MATERIAL_1)
					m1_counter++;
				else if(item == MATERIAL_2)
					m2_counter++;
				else if(item == MATERIAL_3)
					m3_counter++;
				else
				{
					printf("********* error: trying to put undefined material into InputBuffer\n");
					return -1;
				}
				ary[current++] = item;
				return 0;
			}
			else 
			{ /* Error the buffer is full */
				return -1;
			}
		
		
	}	
	Material pop()
	{
		
		if(current > 0) 
		{
			int item = ary[--current];
			if(item == MATERIAL_1)
				m1_counter--;
			else if(item == MATERIAL_2)
				m2_counter--;
			else if(item == MATERIAL_3)
				m3_counter--;
			else
			{
				printf("********** error: There is some undefined material in InputBuffer\n");
				return -1;
			}
			return item;
		}
		else 
		{ /* Error buffer empty */
			return -1;
		}
		
	}	
	void showState()
	{
		printf("The state of InputBuffer Now is:\n");
		printf("Totoal: %d\n", current);
		printf("Material_1: %d\n", m1_counter);
		printf("Material_2: %d\n", m2_counter);
		printf("Material_3: %d\n", m3_counter);
	}	
};

/* The mutex lock */
pthread_mutex_t mutex;

/* the semaphores */
sem_t full, empty;

/* the inputbuffer */
InputBuffer inputBuffer(BUFFER_SIZE);


pthread_t tid;       //Thread ID
pthread_attr_t attr; //Set of thread attributes

void *generator(void *param); /* the generator thread */
void *operators(void *param); /* the operators thread */
int insert_item(Material item);
int remove_item(Material *item);

void initializeData() {

	/* Create the mutex lock */
	pthread_mutex_init(&mutex, NULL);

	/* Create the full semaphore and initialize to 0 */
	sem_init(&full, 0, 0);

	/* Create the empty semaphore and initialize to BUFFER_SIZE */
	sem_init(&empty, 0, BUFFER_SIZE);

	/* Get the default attributes */
	pthread_attr_init(&attr);


}


/* Producer Thread */
void *generator(void *param) 
{
	int generatorID = *(int*)param;
	Material materialID = generatorID;  
	// the materialID is equal to generatorID, which means the material generated by generator1 is 1(MATERIAL_1),etc 
	while(TRUE) {
		/* sleep for a random period of time */
		printf("Now in generator%d, sleep for a while\n",generatorID);
		int rNum = (rand() / RAND_DIVISOR)%100;
		sleep(rNum);
		printf("generator%d finish sleep.\n",generatorID);
		/* acquire the empty lock */
		sem_wait(&empty);
		printf("generator%d finsh to down the semapare.\n", generatorID);
		/* acquire the mutex lock */
		pthread_mutex_lock(&mutex);
		printf("generator%d enter the critical section.\n", generatorID);

		if(inputBuffer.push(materialID) == -1) {
			printf("************* error:generator%d report error condition\n", generatorID);
		}
		else {
			printf("generator%d produced MATERIAL_%d\n", generatorID, materialID);
		}
		/* release the mutex lock */
		pthread_mutex_unlock(&mutex);
		printf("generator%d exits the critical section, and try to up the semephore\n",generatorID);
		/* signal full */
		sem_post(&full);
		printf("generator%d finish up the semephore",generatorID);
	}
	return NULL;
}

/* Consumer Thread */
void *operators(void *param) { 
	int operatorsID = *(int*)param;
	while(TRUE) {
		/* sleep for a random period of time */
		printf("now in operators%d, sleep for a while\n",operatorsID);
		int rNum = (rand() / RAND_DIVISOR)%100;
		sleep(rNum);
		printf("operator%d finish sleep\n",operatorsID);
		/* aquire the full lock */
		printf("operators%d try to down the semaphore\n", operatorsID);
		sem_wait(&full);
		printf("operators%d finish downing the semaphore\n",operatorsID);
		/* aquire the mutex lock */
		pthread_mutex_lock(&mutex);
		printf("operators%d enter the critial section\n",operatorsID);
		Material item = inputBuffer.pop();
		if(item == -1) {
			printf("*************** error:Consumer%d report error condition\n", operatorsID);
		}
		else {
			printf("operators%d consumed %d\n", operatorsID,item);
		}
		/* release the mutex lock */
		pthread_mutex_unlock(&mutex);
		printf("operators%d exit the critical section\n",operatorsID);
		/* signal empty */
		printf("operators%d try to up the semaphore\n",operatorsID);
		sem_post(&empty);
		printf("operators%d finish uping the semaphore\n",operatorsID);
	}
	return NULL;
}

/* Add an item to the buffer */

/* Remove an item from the buffer */


int main(int argc, char *argv[]) {
	/* Loop counter */
	int i;

	/* Verify the correct number of arguments were passed in */
	if(argc != 4) {
		fprintf(stderr, "USAGE:./main.out <INT> <INT> <INT>\n");
	}

	int mainSleepTime = atoi(argv[1]); /* Time in seconds for main to sleep */
	int numProd = atoi(argv[2]); /* Number of generator threads */
	int numCons = atoi(argv[3]); /* Number of operators threads */

	/* Initialize the app */
	initializeData();

	printf("----------------- now in main, before create the generator\n");
	/* Create the generator threads */
	static int proCounter = 0;
	for(i = 0; i < numProd; i++) {
		/* Create the thread */
		proCounter++;
		pthread_create(&tid,&attr,generator,&proCounter);
		
	}
	printf("----------------- now in main, finish create the generator, before create the operators\n");
	/* Create the operators threads */
	static int conCounter = 0;
	for(i = 0; i < numCons; i++) {
		/* Create the thread */
		conCounter++;
		pthread_create(&tid,&attr,operators,&conCounter);
		
	}

	/* Sleep for the specified amount of time in milliseconds */
	printf("---------------- now in main , finish create operators and before main sleep\n");
	sleep(mainSleepTime);

	/* Exit the program */
	printf("Exit the program\n");
	exit(0);
}